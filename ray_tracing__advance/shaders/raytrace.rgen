/*
 * Copyright (c) 2019-2021, NVIDIA CORPORATION.  All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-FileCopyrightText: Copyright (c) 2019-2021 NVIDIA CORPORATION
 * SPDX-License-Identifier: Apache-2.0
 */

#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require

#include "random.glsl"
#include "raycommon.glsl"
#include "wavefront.glsl"

// clang-format off
layout(location = 0) rayPayloadEXT hitPayload prd;

layout(set = 0, binding = eTlas) uniform accelerationStructureEXT topLevelAS;
layout(set = 0, binding = eOutImage, rgba32f) uniform image2D image;
layout(set = 1, binding = eGlobals) uniform _GlobalUniforms { GlobalUniforms uni; };
layout(push_constant) uniform _PushConstantRay { PushConstantRay pcRay; };
// clang-format on

//  
layout(set = 1, binding = eAtrInfo) uniform _AtrInfoUniforms { AtrInfo ai; };
layout(set = 1, binding = eAtrSamplerLinear) uniform sampler AtrSampLin;
layout(set = 1, binding = eAtrTexture) uniform texture3D atrTexture;
layout(set = 1, binding = eColormapTexture) uniform texture1D colormapTexture;


const int NBSAMPLES = 1;

vec4 mapColormap (float value);

void main()
{
  // Initialize the random number
  uint seed = tea(gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x, pcRay.frame * NBSAMPLES);
  prd.seed  = seed;

  vec4 hitValues = vec4(0);

  for(int smpl = 0; smpl < NBSAMPLES; smpl++)
  {

    float r1 = rnd(seed);
    float r2 = rnd(seed);
    // Subpixel jitter: send the ray through a different position inside the pixel
    // each time, to provide antialiasing.
    vec2 subpixel_jitter = pcRay.frame == 0 ? vec2(0.5f, 0.5f) : vec2(r1, r2);

    const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + subpixel_jitter;


    const vec2 inUV = pixelCenter / vec2(gl_LaunchSizeEXT.xy);
    vec2       d    = inUV * 2.0 - 1.0;

    vec4 origin    = uni.viewInverse * vec4(0, 0, 0, 1);
    vec4 target    = uni.projInverse * vec4(d.x, d.y, 1, 1);
    vec4 direction = uni.viewInverse * vec4(normalize(target.xyz), 0);

    uint  rayFlags = gl_RayFlagsNoOpaqueEXT;
//    float tMin     = 0.001;
//    float tMax     = 10000.0;

    vec3 minCorner = ai.minPoint.xyz;
    vec3 maxCorner = ai.minPoint.xyz + ai.dimension.xyz;
    
    vec3 s1, s2;
    vec3 n1 = vec3(-1.f, 0.f,  0.f);
    vec3 n2 = vec3( 0.f, -1.f,  0.f);
    vec3 n3 = vec3( 0.f,  0.f, -1.f);
    vec3 n4 = vec3( 1.f,  0.f,  0.f);
    vec3 n5 = vec3( 0.f,  1.f,  0.f);
    vec3 n6 = vec3( 0.f,  0.f,  1.f);
    
    float t1 = dot((minCorner - origin.xyz), n1) / dot (n1, direction.xyz);
    float t2 = dot((minCorner - origin.xyz), n2) / dot (n2, direction.xyz);
    float t3 = dot((minCorner - origin.xyz), n3) / dot (n3, direction.xyz);
    float t4 = dot((maxCorner - origin.xyz), n4) / dot (n4, direction.xyz);
    float t5 = dot((maxCorner - origin.xyz), n5) / dot (n5, direction.xyz);
    float t6 = dot((maxCorner - origin.xyz), n6) / dot (n6, direction.xyz);

    if(t1 > t4) { float tmp = t4; t4 = t1; t1 = tmp; }
    if(t2 > t5) { float tmp = t5; t5 = t2; t2 = tmp; }
    if(t3 > t6) { float tmp = t6; t6 = t3; t3 = tmp; }
    
    float tMin = max(t1, max(t2, t3));
    float tMax = min(t4, min(t5, t6));

    prd.done                = 1;
    prd.rayOrigin           = origin.xyz;
    prd.rayDir              = direction.xyz;
    prd.depth               = 0;
    prd.hitValue            = vec4(0.f, 0.f,0.f ,0.f);
    prd.attenuation         = vec4(1.f, 1.f, 1.f, 1.f);
    prd.lastT               = -1.f;
    prd.hitCount            = 0;

    for(int i=0; i<maxHitCount; i++) {
        prd.hitAttributes[i] = 0.f;
        prd.hitDistances[i]  = 0.f;
    }

    //for(;;)
    //{

#if 0
      traceRayEXT(topLevelAS,     // acceleration structure
                  rayFlags,       // rayFlags
                  0xFF,           // cullMask
                  0,              // sbtRecordOffset
                  0,              // sbtRecordStride
                  0,              // missIndex
                  origin.xyz,     // ray origin
                  tMin,           // ray min range
                  direction.xyz,  // ray direction
                  tMax,           // ray max range
                  0               // payload (location = 0)
      );
#else
    
    if(tMax > tMin && tMin > 0) {
        float stepSize = (tMax - tMin) / 100.f;
        float t = tMin;
        for(int i=0; i<100; ++i) {
            vec3 p = origin.xyz + t * direction.xyz;
            vec3 normalizedCoord = (p - ai.minPoint.xyz) / ai.dimension.xyz;
            float attr = texture(sampler3D(atrTexture, AtrSampLin), normalizedCoord).x;
            if(attr >= ai.ISOValue) {
                hitValues = mapColormap(attr);
                break;
            }
            t += stepSize;
        }
    }
#endif


      //hitValues = prd.hitValue * prd.attenuation;// hitValues += prd.hitValue * prd.attenuation;

     // prd.depth++;
      //if(prd.done == 1 || prd.depth >= 10)
     //   break;

      //origin.xyz    = prd.rayOrigin;
      //direction.xyz = prd.rayDir;
      //prd.done      = 1;  // Will stop if a reflective material isn't hit
    //}
  }
  

  /*
  vec2 subpixel_jitter = vec2(0.f, 0.f);
  const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + subpixel_jitter;
  const vec2 inUV = pixelCenter / vec2(gl_LaunchSizeEXT.xy);
  vec2       d   = inUV * 2.0 - 1.0;
  vec4 origin    = uni.viewInverse * vec4(0, 0, 0, 1);
  vec4 target    = uni.projInverse * vec4(d.x, d.y, 1, 1);
  vec4 direction = uni.viewInverse * vec4(normalize(target.xyz), 0);
  uint  rayFlags = gl_RayFlagsNoOpaqueEXT;

  vec3 minCorner = ai.minPoint.xyz;
  vec3 maxCorner = ai.minPoint.xyz + ai.dimension.xyz;

  vec3 s1, s2;
  vec3 n1 = vec3(0.f, -1.f, 0.f);
  vec3 n2 = vec3(-1.f, 0.f, 0.f);
  vec3 n3 = vec3(0.f, 0.f, -1.f);
  vec3 n4 = vec3(0.f, 1.f, 0.f);
  vec3 n5 = vec3(1.f, 0.f, 0.f);
  vec3 n6 = vec3(0.f, 0.f, 1.f);
  
  float t1 = dot((minCorner - origin.xyz), n1) / dot (n1, direction.xyz);
  float t2 = dot((minCorner - origin.xyz), n2) / dot (n2, direction.xyz);
  float t3 = dot((minCorner - origin.xyz), n3) / dot (n3, direction.xyz);
  float t4 = dot((maxCorner - origin.xyz), n4) / dot (n4, direction.xyz);
  float t5 = dot((maxCorner - origin.xyz), n5) / dot (n5, direction.xyz);
  float t6 = dot((maxCorner - origin.xyz), n6) / dot (n6, direction.xyz);

  float tMin = max(t1, max(t2, t3));
  float tMax = min(t4, min(t5, t6));
  prd.done                = 1;
  prd.rayOrigin           = origin.xyz;
  prd.rayDir              = direction.xyz;
  prd.depth               = 0;
  prd.hitValue            = vec4(0.f, 0.f,0.f ,0.f);
  prd.attenuation         = vec4(1.f, 1.f, 1.f, 1.f);
  prd.lastT               = -1.f;
  prd.hitCount            = 0;

  for(int i=0; i<maxHitCount; i++) {
      prd.hitAttributes[i] = 0.f;
      prd.hitDistances[i]  = 0.f;
  }

  

  traceRayEXT(topLevelAS,     // acceleration structure
                  rayFlags,       // rayFlags
                  0xFF,           // cullMask
                  0,              // sbtRecordOffset
                  0,              // sbtRecordStride
                  0,              // missIndex
                  origin.xyz,     // ray origin
                  tMin,           // ray min range
                  direction.xyz,  // ray direction
                  tMax,           // ray max range
                  0               // payload (location = 0)
      );

   hitValues = prd.hitValue * prd.attenuation;// hitValues += prd.hitValue * prd.attenuation;
   */
   prd.hitValue = hitValues;// / NBSAMPLES;

  // Do accumulation over time
  if(pcRay.frame >= 0)
  {
    float a         = 1.0f / float(pcRay.frame + 1);
    vec3  old_color = imageLoad(image, ivec2(gl_LaunchIDEXT.xy)).xyz;
    imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(mix(old_color, prd.hitValue.rgb, a), 1.f));
  }
  else
  {
    // First frame, replace the value in the buffer
    imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(prd.hitValue.rgb, 1.f));
  }
}

vec4 mapColormap (float value) {
    float normalizedValue = (value - ai.minAtrValue) / (ai.maxAtrValue - ai.minAtrValue);
    vec4 color =  texture(sampler1D(colormapTexture, AtrSampLin), normalizedValue);
    return color;
}