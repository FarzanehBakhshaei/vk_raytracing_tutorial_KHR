/*
 * Copyright (c) 2019-2021, NVIDIA CORPORATION.  All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-FileCopyrightText: Copyright (c) 2019-2021 NVIDIA CORPORATION
 * SPDX-License-Identifier: Apache-2.0
 */

#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require

#include "random.glsl"
#include "raycommon.glsl"
#include "wavefront.glsl"

// clang-format off
layout(location = 0) rayPayloadEXT hitPayload prd;

layout(set = 0, binding = eTlas) uniform accelerationStructureEXT topLevelAS;
layout(set = 0, binding = eOutImage, rgba32f) uniform image2D image;
layout(set = 1, binding = eGlobals) uniform _GlobalUniforms { GlobalUniforms uni; };
layout(push_constant) uniform _PushConstantRay { PushConstantRay pcRay; };
// clang-format on

//  
layout(set = 1, binding = eAtrInfo) uniform _AtrInfoUniforms { AtrInfo ai; };
layout(set = 1, binding = eAtrSamplerLinear) uniform sampler AtrSampLin;
layout(set = 1, binding = eAtrTexture) uniform texture3D atrTexture;
layout(set = 1, binding = eColormapTexture) uniform texture1D colormapTexture;
layout(location = 3) callableDataEXT rayLight cLight;


const int NBSAMPLES = 1;

vec4 mapColormap (float value);
#define ENABLED_REFINEMENT 1
#define ENABLED_ISOVALUE 1

void main()
{
  // Initialize the random number
  uint seed = tea(gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x, pcRay.frame * NBSAMPLES);
  prd.seed  = seed;

  vec4 hitValues = vec4(0);
  vec3 normal = vec3(0.f);

  for(int smpl = 0; smpl < NBSAMPLES; smpl++)
  {

    float r1 = rnd(seed);
    float r2 = rnd(seed);
    // Subpixel jitter: send the ray through a different position inside the pixel
    // each time, to provide antialiasing.
    vec2 subpixel_jitter = pcRay.frame == 0 ? vec2(0.5f, 0.5f) : vec2(r1, r2);

    const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + subpixel_jitter;


    const vec2 inUV = pixelCenter / vec2(gl_LaunchSizeEXT.xy);
    vec2       d    = inUV * 2.0 - 1.0;

    vec4 origin    = uni.viewInverse * vec4(0, 0, 0, 1);
    vec4 target    = uni.projInverse * vec4(d.x, d.y, 1, 1);
    vec4 direction = uni.viewInverse * vec4(normalize(target.xyz), 0);

    uint  rayFlags = gl_RayFlagsNoOpaqueEXT;
//    float tMin     = 0.001;
//    float tMax     = 10000.0;

    vec3 minCorner = ai.minPoint.xyz;
    vec3 maxCorner = ai.minPoint.xyz + ai.dimension.xyz;
    
    vec3 s1, s2;
    vec3 n1 = vec3(-1.f, 0.f,  0.f);
    vec3 n2 = vec3( 0.f, -1.f,  0.f);
    vec3 n3 = vec3( 0.f,  0.f, -1.f);
    vec3 n4 = vec3( 1.f,  0.f,  0.f);
    vec3 n5 = vec3( 0.f,  1.f,  0.f);
    vec3 n6 = vec3( 0.f,  0.f,  1.f);
    
    float t1 = dot((minCorner - origin.xyz), n1) / dot (n1, direction.xyz);
    float t2 = dot((minCorner - origin.xyz), n2) / dot (n2, direction.xyz);
    float t3 = dot((minCorner - origin.xyz), n3) / dot (n3, direction.xyz);
    float t4 = dot((maxCorner - origin.xyz), n4) / dot (n4, direction.xyz);
    float t5 = dot((maxCorner - origin.xyz), n5) / dot (n5, direction.xyz);
    float t6 = dot((maxCorner - origin.xyz), n6) / dot (n6, direction.xyz);

    if(t1 > t4) { float tmp = t4; t4 = t1; t1 = tmp; }
    if(t2 > t5) { float tmp = t5; t5 = t2; t2 = tmp; }
    if(t3 > t6) { float tmp = t6; t6 = t3; t3 = tmp; }
    
    float tMin = max(t1, max(t2, t3));
    float tMax = min(t4, min(t5, t6));

    prd.done                = 1;
    prd.rayOrigin           = origin.xyz;
    prd.rayDir              = direction.xyz;
    prd.depth               = 0;
    prd.hitValue            = vec4(0.f, 0.f,0.f ,0.f);
    prd.attenuation         = vec4(1.f, 1.f, 1.f, 1.f);
    prd.lastT               = -1.f;
    prd.hitCount            = 0;

    for(int i=0; i<maxHitCount; i++) {
        prd.hitAttributes[i] = 0.f;
        prd.hitDistances[i]  = 0.f;
    }

    //for(;;)
    //{

#if 0
      traceRayEXT(topLevelAS,     // acceleration structure
                  rayFlags,       // rayFlags
                  0xFF,           // cullMask
                  0,              // sbtRecordOffset
                  0,              // sbtRecordStride
                  0,              // missIndex
                  origin.xyz,     // ray origin
                  tMin,           // ray min range
                  direction.xyz,  // ray direction
                  tMax,           // ray max range
                  0               // payload (location = 0)
      );
#else
    hitValues = vec4 (pcRay.clearColor.xyz * 0.8, 1.f);
    
    float tPlane = dot((ai.planePosition - origin.xyz), ai.planeNormal) / dot (ai.planeNormal, direction.xyz);
    //tMax = min(tMax, tPlane);
    float planeSize = length(maxCorner - minCorner) * 1.5f;
    vec3 distanceToPlaneCenter = origin.xyz + tPlane * direction.xyz - ai.planePosition;
    bool ignoreRayTracing = false;
    
    vec3 entryPos = origin.xyz + tMin * direction.xyz;
    vec3 exitPos = origin.xyz + tMax * direction.xyz;

    float entryPosProj = dot(entryPos - ai.planePosition, ai.planeNormal);
    float exitPosProj = dot(exitPos - ai.planePosition, ai.planeNormal);
    bool stopRay = false;

    // if both entry and exit points are on the side of the clip plane that 
    // they should be clipped
    if(entryPosProj > 0 && exitPosProj > 0) {
        ignoreRayTracing = true;
    }

    // if entry point is on the side of plane that should be clipped
    if(entryPosProj > 0)
        tMin = max(tMin, tPlane);

    // if exit point is on the side of plane that should be clipped 
    if(exitPosProj > 0)
        tMax = min(tMax, tPlane);
        
    if(abs(length(distanceToPlaneCenter) - planeSize / 2) < 2) {
        //ignoreRayTracing = true;
        tMax = min(tMax, tPlane);
        hitValues = vec4 (1.f, 0.f, 0.f, 0.f);
    }
    
    if(length(distanceToPlaneCenter) < 2 && dot(distanceToPlaneCenter, ai.planeNormal) > 0) {
        ignoreRayTracing = true;
        hitValues = vec4 (0.f, 0.f, 1.f, 0.f);
    }
        
        
    if(tMax > tMin && tMin > 0 && !ignoreRayTracing) {
        float stepSize = length(maxCorner - minCorner) / 200.f;//(tMax - tMin) / 100.f;
        float t = tMin;
        
        for(int i=0; i<500 && t < tMax; ++i , t += stepSize) {
            vec3 p = origin.xyz + t * direction.xyz;
            vec3 normalizedCoord = (p - ai.minPoint.xyz) / ai.dimension.xyz;
                        
            float attr = texture(sampler3D(atrTexture, AtrSampLin), normalizedCoord).x;
#if ENABLED_ISOVALUE
            if(attr >= ai.ISOValue) 
            {
                // lighting. Computing normal with gradient of the surface
                float f_XPlusDeltaX    = texture(sampler3D(atrTexture, AtrSampLin), clamp (normalizedCoord + vec3(1.0f/ai.dimension.x, 0.0f, 0.0f), 0.0f, 1.0f)).r;
                float f_XMinusDeltaX   = texture(sampler3D(atrTexture, AtrSampLin), clamp (normalizedCoord - vec3(1.0f/ai.dimension.x, 0.0f, 0.0f), 0.0f, 1.0f)).r;
                float f_YPlusDeltaY    = texture(sampler3D(atrTexture, AtrSampLin), clamp (normalizedCoord + vec3(0.0f, 1.0f/ai.dimension.y, 0.0f), 0.0f, 1.0f)).r;
                float f_YMinusDeltaY   = texture(sampler3D(atrTexture, AtrSampLin), clamp (normalizedCoord - vec3(0.0f, 1.0f/ai.dimension.y, 0.0f), 0.0f, 1.0f)).r;
                float f_ZPlusDeltaZ    = texture(sampler3D(atrTexture, AtrSampLin), clamp (normalizedCoord + vec3(0.0f, 0.0f, 1.0f/ai.dimension.z), 0.0f, 1.0f)).r;
                float f_ZMinusDeltaZ   = texture(sampler3D(atrTexture, AtrSampLin), clamp (normalizedCoord - vec3(0.0f, 0.0f, 1.0f/ai.dimension.z), 0.0f, 1.0f)).r;
                
                vec3 n = vec3 (f_XPlusDeltaX - f_XMinusDeltaX, f_YPlusDeltaY - f_YMinusDeltaY, f_ZPlusDeltaZ - f_ZMinusDeltaZ) * ai.dimension.xyz * 0.5f;
                if(dot(n, n) < 0.001f)    // |n^2| < 0.001f
                    normal = vec3(0.0f);
                else
                    normal = normalize(n);
#if ENABLED_REFINEMENT
                vec3 lastPos = origin.xyz + (t-stepSize) * direction.xyz;
                for (int i=0; i<10; i++) {
                    vec3 midPos = (p + lastPos)/2.f;
                    normalizedCoord = (midPos - ai.minPoint.xyz) / ai.dimension.xyz;
                    attr = texture(sampler3D(atrTexture, AtrSampLin), normalizedCoord).x;
                    if(attr >= ai.ISOValue) {
                        p = midPos;
                    } else {
                        lastPos = midPos;
                    }
                }
#endif
                normalizedCoord = (p - ai.minPoint.xyz) / ai.dimension.xyz;
                attr = texture(sampler3D(atrTexture, AtrSampLin), normalizedCoord).x;
                hitValues = mapColormap(attr);
                break;
            } 
#endif
        }

    }
#endif


      //hitValues = prd.hitValue * prd.attenuation;// hitValues += prd.hitValue * prd.attenuation;

     // prd.depth++;
      //if(prd.done == 1 || prd.depth >= 10)
     //   break;

      //origin.xyz    = prd.rayOrigin;
      //direction.xyz = prd.rayDir;
      //prd.done      = 1;  // Will stop if a reflective material isn't hit
    //}
  }
  

  /*
  vec2 subpixel_jitter = vec2(0.f, 0.f);
  const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + subpixel_jitter;
  const vec2 inUV = pixelCenter / vec2(gl_LaunchSizeEXT.xy);
  vec2       d   = inUV * 2.0 - 1.0;
  vec4 origin    = uni.viewInverse * vec4(0, 0, 0, 1);
  vec4 target    = uni.projInverse * vec4(d.x, d.y, 1, 1);
  vec4 direction = uni.viewInverse * vec4(normalize(target.xyz), 0);
  uint  rayFlags = gl_RayFlagsNoOpaqueEXT;

  vec3 minCorner = ai.minPoint.xyz;
  vec3 maxCorner = ai.minPoint.xyz + ai.dimension.xyz;

  vec3 s1, s2;
  vec3 n1 = vec3(0.f, -1.f, 0.f);
  vec3 n2 = vec3(-1.f, 0.f, 0.f);
  vec3 n3 = vec3(0.f, 0.f, -1.f);
  vec3 n4 = vec3(0.f, 1.f, 0.f);
  vec3 n5 = vec3(1.f, 0.f, 0.f);
  vec3 n6 = vec3(0.f, 0.f, 1.f);
  
  float t1 = dot((minCorner - origin.xyz), n1) / dot (n1, direction.xyz);
  float t2 = dot((minCorner - origin.xyz), n2) / dot (n2, direction.xyz);
  float t3 = dot((minCorner - origin.xyz), n3) / dot (n3, direction.xyz);
  float t4 = dot((maxCorner - origin.xyz), n4) / dot (n4, direction.xyz);
  float t5 = dot((maxCorner - origin.xyz), n5) / dot (n5, direction.xyz);
  float t6 = dot((maxCorner - origin.xyz), n6) / dot (n6, direction.xyz);

  float tMin = max(t1, max(t2, t3));
  float tMax = min(t4, min(t5, t6));
  prd.done                = 1;
  prd.rayOrigin           = origin.xyz;
  prd.rayDir              = direction.xyz;
  prd.depth               = 0;
  prd.hitValue            = vec4(0.f, 0.f,0.f ,0.f);
  prd.attenuation         = vec4(1.f, 1.f, 1.f, 1.f);
  prd.lastT               = -1.f;
  prd.hitCount            = 0;

  for(int i=0; i<maxHitCount; i++) {
      prd.hitAttributes[i] = 0.f;
      prd.hitDistances[i]  = 0.f;
  }

  

  traceRayEXT(topLevelAS,     // acceleration structure
                  rayFlags,       // rayFlags
                  0xFF,           // cullMask
                  0,              // sbtRecordOffset
                  0,              // sbtRecordStride
                  0,              // missIndex
                  origin.xyz,     // ray origin
                  tMin,           // ray min range
                  direction.xyz,  // ray direction
                  tMax,           // ray max range
                  0               // payload (location = 0)
      );

   hitValues = prd.hitValue * prd.attenuation;// hitValues += prd.hitValue * prd.attenuation;
   */
   prd.hitValue = hitValues;// / NBSAMPLES;

   // Point light
   if(pcRay.lightType == 0)
   {
     vec3  lDir              = pcRay.lightPosition - cLight.inHitPosition;
     float lightDistance     = length(lDir);
     cLight.outIntensity     = pcRay.lightIntensity / (lightDistance * lightDistance);
     cLight.outLightDir      = normalize(lDir);
     cLight.outLightDistance = lightDistance;
   }
   else if(pcRay.lightType == 1) // spot light
   {
     vec3 lDir               = pcRay.lightPosition - cLight.inHitPosition;
     cLight.outLightDistance = length(lDir);
     cLight.outIntensity     = pcRay.lightIntensity / (cLight.outLightDistance * cLight.outLightDistance);
     cLight.outLightDir      = normalize(lDir);
     float theta             = dot(cLight.outLightDir, normalize(-pcRay.lightDirection));
     float epsilon           = pcRay.lightSpotCutoff - pcRay.lightSpotOuterCutoff;
     float spotIntensity     = clamp((theta - pcRay.lightSpotOuterCutoff) / epsilon, 0.0, 1.0);
     cLight.outIntensity *= spotIntensity;
   }
   else  // Directional light
   {
     cLight.outLightDir      = normalize(-pcRay.lightDirection);
     cLight.outIntensity     = 1.0;
     cLight.outLightDistance = 10000000;
   }
   // Diffuse
   vec3 diffuse = length (normal) < 0.001 ? vec3(1.f) : computeDiffuse(cLight.outLightDir, normal);
   //
   prd.hitValue = prd.hitValue * vec4(cLight.outIntensity * diffuse, 1.f);

  // Do accumulation over time
  if(pcRay.frame >= 0)
  {
    float a         = 1.0f / float(pcRay.frame + 1);
    vec3  old_color = imageLoad(image, ivec2(gl_LaunchIDEXT.xy)).xyz;
    imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(mix(old_color, prd.hitValue.rgb, a), 1.f));
  }
  else
  {
    // First frame, replace the value in the buffer
    imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(prd.hitValue.rgb, 1.f));
  }

  
  
}

vec4 mapColormap (float value) {
    float normalizedValue = (value - ai.minAtrValue) / (ai.maxAtrValue - ai.minAtrValue);
    vec4 color =  texture(sampler1D(colormapTexture, AtrSampLin), normalizedValue);
    return color;
}